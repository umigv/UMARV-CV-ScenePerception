# {Post-Processing Approaches}
### by {Ryan Aspenleiter}

# Model description
The code in this folder is meant to showcase different approaches to removing noise generated by segmentation models (drivable area, etc.) we use in competition. Our segmentation models generate 2d array masks that describe what classes are present in the given pixel. Two approaches for post-processing these masks are implemented:

## OpenCV Erode & Dilate
This is the significantly simpler and faster approach. OpenCV provides an erode and a dilate function that erode noise and dilate regions of class detection respectively. For this code, it is implemented in utils.py with erodeAndDilate(), which applies an erosion to remove small noisy regions, followed by multiple dilations to refill our real class detection regions, followed by a final erosion to remove effects from excess dilation.

## DBScan and Boundary Sets
This approach is theoretically more accurate than the prior approach but is much more complex and runs much more slowly. DBScan is a clustering algorithm which detects clusters of similar datapoints within a dataset and assigns the datapoints labels based on that. With DBScan, we can detect clusters describing the real class detection regions and determine noisy datapoints that don't fall under any of our clusters. 

However, simply running DBScan and removing noisy datapoints isn't enough, as it cannot do anything to help with false negative detections. To solve this, the containing geometry / boundary set of each cluster found by DBScan is calculated (ConvexHull() function). Each bounding geometry is then filled to create a set of masks and are stacked via logical_or() to create good masks.

This is as far as the current implementation goes, but more complex detection shapes can ruin this approach. For instance, a donut-shaped detection would create false positive detections. A complete implementation would involve generating bounding geometries for both positive detection and negative detection regions, calculate which regions are contained by other regions, and combine the resulting masks together in a manner not to remove information gained by any particular mask. Unfortunately, this step is computationally expensive.

# Visual results explanation
When running main.py, the result is a table of images with regions of no class detection removed for each approach. There are also Diff images, which show the differences between masks generated from different approaches and the true mask (In a perfect case, this diff image should be solid white). Several variables can be modified to explore different outcomes of the above approaches. 

In roboflow_processing.py, download_dataset() contains standard code for loading a drivable area model from Roboflow. This code can be replaced with code given by Roboflow for other models without issue. load_and_run_models() loads the model located at MODEL_LOC (line 18), and runs it on the image data located at TEST_CASE/TEST_IMG_LOC to gather raw prediction results, the image data for the specified image, and the theoretically perfect mask for class data.

In main.py, include_erode_dilate and include_dbscan can be toggled to not run some of the approaches described above (include_dbscan=True results in long runtimes). eps and min_samples are used by DBScan to determine whether nearby points are neighbors or not (existing values seem to work fine). sigma_vals is an array of floats describing the intensities of noise to add to the results of the original segmentation model.

# Notes
There was a bug in data.yaml for the dataset. Change the train-test-split directories to match the format of the test directory to fix it.

Also, as a general note, file paths may need to be modified throughout depending on local directory structure. Changes should be minimal.